-- Script generated by Redgate Compare v1.21.2.22957
SET check_function_bodies = false;


DO language plpgsql $$BEGIN RAISE NOTICE 'Dropping public.c_inv...';END$$;
DROP TABLE public.c_inv;


DO language plpgsql $$BEGIN RAISE NOTICE 'Dropping public.test_func(numeric, numeric, integer)...';END$$;
DROP FUNCTION public.test_func(numeric, numeric, integer);


DO language plpgsql $$BEGIN RAISE NOTICE 'Dropping public.t2()...';END$$;
DROP FUNCTION public.t2();


DO language plpgsql $$BEGIN RAISE NOTICE 'Dropping public.bıgınt...';END$$;
DROP DOMAIN public.bıgınt;


DO language plpgsql $$BEGIN RAISE NOTICE 'Altering public.random_between(numeric, numeric, integer)...';END$$;
CREATE OR REPLACE FUNCTION public.random_between(IN min_val numeric, IN max_val numeric, IN round_to integer DEFAULT 0)
RETURNS numeric
LANGUAGE plpgsql
AS $_$
 DECLARE
 	value NUMERIC = random()* (min_val - max_val) + max_val;
BEGIN
   IF round_to = 0 THEN 
	 RETURN floor(value);
   ELSE 
   	 RETURN round(value,round_to);
   END IF;
END
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Altering public.get_inventory()...';END$$;
CREATE OR REPLACE FUNCTION public.get_inventory()
RETURNS TABLE(film_id bigint, popularity real, total_i integer[], x numeric)
LANGUAGE plpgsql
AS $_$
BEGIN
	RETURN query 
	WITH inventory_tmp (film_id, popularity, total_i, release_date) AS (
	SELECT f.film_id, f.popularity, CASE
		WHEN f.popularity <= 20 THEN ARRAY[0,2]
		WHEN f.popularity BETWEEN 20 AND 35 THEN ARRAY[0,2]
		WHEN f.popularity BETWEEN 35 AND 75 THEN ARRAY[1,3]
		WHEN f.popularity BETWEEN 75 AND 100 THEN ARRAY[2,6]
		WHEN f.popularity BETWEEN 100 AND 500 THEN ARRAY[3,6]
		WHEN f.popularity >500 THEN ARRAY[6,10]
		END,
		release_date
	FROM film f
),
adjusted_inventory AS (
	SELECT it.film_id, it.popularity, 
	CASE 
		WHEN release_date > now()-'1 year'::INTERVAL THEN it.total_i
		WHEN release_date BETWEEN now()-'3 years'::INTERVAL AND now()-'1 year'::INTERVAL THEN
			array_agg(greatest(val-1,0))
		WHEN release_date BETWEEN now()-'4 years'::INTERVAL AND now()-'3 year'::INTERVAL THEN
			array_agg(greatest(val-2,0))
		WHEN release_date < now()-'3 years'::INTERVAL THEN
			array_agg(greatest(val-3,0))
	END AS total_i
	FROM inventory_tmp it, unnest(it.total_i) AS val
	GROUP BY it.film_id, it.popularity, it.release_date, it.total_i
)
SELECT ai.film_id, ai.popularity, ai.total_i, x.i FROM adjusted_inventory ai, random_between(ai.total_i[1],ai.total_i[2]) x(i);

END; $_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.insert_single_payment(integer)...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.insert_single_payment(IN rid integer)
LANGUAGE plpgsql
AS $_$	
 DECLARE
 	rental_rate float4 = 1.99;
 BEGIN 
	WITH payment_info AS (
		SELECT rental_id, rental_period, GREATEST(CEILING(EXTRACT(epoch from (upper(rental_period)-lower(rental_period)))/3600/24),1) rental_days,
			inventory_id, customer_id, upper(rental_period) AS payment_date
		FROM bluebox.rental r
			INNER JOIN bluebox.inventory i USING(inventory_id)
			INNER JOIN bluebox.film f USING(film_id)
		WHERE r.rental_id = rid
	)
	INSERT INTO bluebox.payment (customer_id, rental_id, amount, payment_date)
	SELECT customer_id, rental_id, rental_days*rental_rate AS amount, payment_date
		FROM payment_info;
	
	END;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.insert_payments(date)...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.insert_payments(IN rd date)
LANGUAGE plpgsql
AS $_$	
 DECLARE
 	rental_rate float4 = 1.99;
 BEGIN 
	WITH payment_info AS (
		SELECT r.rental_id, rental_period, GREATEST(CEILING(EXTRACT(epoch from (upper(rental_period)-lower(rental_period)))/3600/24),1) rental_days,
			inventory_id, r.customer_id, upper(rental_period) AS payment_date
		FROM bluebox.rental r
			INNER JOIN bluebox.inventory i USING(inventory_id)
			INNER JOIN bluebox.film f USING(film_id)
			LEFT JOIN bluebox.payment p ON r.rental_id = p.rental_id
		WHERE lower(rental_period) >= rd AND lower(rental_period) <= rd+'5 days'::INTERVAL
		AND p.rental_id IS NULL 
	)
	INSERT INTO bluebox.payment (customer_id, rental_id, amount, payment_date)
	SELECT customer_id, rental_id, rental_days*rental_rate AS amount, payment_date
		FROM payment_info;
	
	END;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.generate_rental_history(timestamp with time zone, timestamp with time zone, numeric, double)...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.generate_rental_history(IN data_start timestamp with time zone, IN data_end timestamp with time zone, IN max_cust_pct numeric DEFAULT 2.5, IN holiday_multiplier double precision DEFAULT 2.5)
LANGUAGE plpgsql
AS $_$
 DECLARE cus record;
	c_inv int;
	a_inv int[];
	rental_start timestamptz;
    rental_nextday timestamptz;
    rental_period_lower timestamptz;
    rental_period_upper timestamptz;
	cust_percent float4 = 1.2;
	cid bigint;
	total_cus bigint;
 BEGIN
	 
	IF data_start > data_end THEN
		RAISE EXCEPTION 'End date must be after start date!';
	END IF;
	
	IF (data_end-data_start) > '365 days'::INTERVAL THEN
		RAISE EXCEPTION 'You can only do one year at time! %', (data_end-data_start);
	END IF;

	rental_start = data_start;

	CREATE TEMPORARY TABLE IF NOT EXISTS tmp_av_customer(LIKE bluebox.customer INCLUDING ALL);
	CREATE TEMPORARY TABLE IF NOT EXISTS tmp_av_inventory (LIKE bluebox.inventory INCLUDING ALL);

--	CREATE INDEX tmp_av_inventory_id ON tmp_av_inventory (inventory_id);

	WHILE rental_start <= data_end THEN
	LOOP -- daily LOOP FOR rentals
		a_inv := null;
		-- precautionary if they existed or some reason
		TRUNCATE tmp_av_customer;
		TRUNCATE tmp_av_inventory; 
	
	
	-- this is used during the INSERT and pulled out here for visibility
		rental_nextday = rental_start + '1 day'::INTERVAL;
		SELECT pct INTO cust_percent FROM random_between(0.8,max_cust_pct,3) x(pct);
		
--		RAISE NOTICE 'rental_start: %', rental_start;
--		RAISE NOTICE 'rental_nextday: %', rental_nextday;
	--	RAISE NOTICE 'data_end: %', data_end;	

		IF EXISTS (SELECT 1 FROM bluebox.holiday WHERE holiday_date::timestamptz <@ tstzrange(rental_start,rental_nextday)) THEN 
			SELECT pct INTO cust_percent FROM random_between(2.6,(cust_percent*holiday_multiplier)::numeric,3) x(pct);
		END IF;
	
		--RAISE NOTICE 'customer pct: %', cust_percent;		
	
		-- Get a list of inventory that is currently on loan as of the rental_start day
		WITH outstanding_rentals AS MATERIALIZED (
			SELECT * FROM bluebox.rental
			WHERE rental_period @> tstzrange(rental_start, rental_nextday)
		),
		-- get a list of inventory that is available
		available_inventory AS (
			INSERT INTO tmp_av_inventory
			SELECT i.* FROM bluebox.inventory i
				INNER JOIN film f USING(film_id)
				LEFT JOIN outstanding_rentals o using(inventory_id)
			WHERE o.inventory_id IS NULL
				AND release_date <= rental_start::date
		)
		--SELECT * FROM available_inventory;
		-- get a list of customers that do not currently have a video on loan
		-- as of today
		INSERT INTO tmp_av_customer
		SELECT c.* FROM bluebox.customer c
		 	LEFT JOIN outstanding_rentals o using(customer_id)
		WHERE o.customer_id IS NULL;
		 
		ANALYZE tmp_av_inventory;
		ANALYZE tmp_av_customer;
		-- sample 3% of the rows from available customers for the given day 
		-- loop over them and
--	 	SELECT count(*) INTO total_cus FROM tmp_av_customer TABLESAMPLE bernoulli(cust_percent);
--		RAISE NOTICE 'total customer to generate rentals for: %', total_cus;
--	
--		SELECT count(*) INTO total_cus FROM tmp_av_inventory;
--		RAISE NOTICE 'total inventory: %', total_cus;
	 	
		FOR cus IN (SELECT customer_id, store_id FROM tmp_av_customer TABLESAMPLE bernoulli(cust_percent))
	 	LOOP
		 	cid := cus.store_id;
		 	-- This is not efficient on larger tables. For a small table like this
		 	-- using 'random()' to order is faster and easier than a multi-step search
		 	WITH rental_store_inv AS (
				SELECT s.store_id, ST_Distance(s.geog,c.geog) dist FROM bluebox.store s,
					bluebox.customer c
				WHERE ST_DWithin(s.geog,c.geog,25000)
					AND c.customer_id = cus.customer_id
				ORDER BY random()
				LIMIT 1
			)
			SELECT store_id INTO cus.store_id FROM rental_store_inv;
		
			IF(cus.store_id IS NULL) THEN
				cus.store_id := cid;
			END IF;
	 	
		 	SELECT inventory_id INTO c_inv FROM tmp_av_inventory ai
		 		WHERE inventory_id NOT IN (SELECT UNNEST(a_inv))
		 			AND ai.store_id = cus.store_id
		 		ORDER BY random()
		 		LIMIT 1;
		 	
		 	--RAISE NOTICE 'customer_id: %, inventory_id: %, store_id: %',cus.customer_id, c_inv, cus.store_id;
		 	
			WITH return_store_inv AS (
				SELECT s.store_id, ST_Distance(s.geog,c.geog) dist FROM bluebox.store s,
					bluebox.customer c
				WHERE ST_DWithin(s.geog,c.geog,25000)
					AND c.customer_id = cus.customer_id
				ORDER BY random()
				LIMIT 1
			)
			SELECT COALESCE(store_id, cus.store_id) INTO cus.store_id FROM return_store_inv;		 	
		 	
			IF(cus.store_id IS NULL) THEN
				cus.store_id := cid;
			END IF;		
		
		 	--RAISE NOTICE 'Return Store: customer_id: %, inventory_id: %, store_id: %',cus.customer_id, c_inv, cus.store_id;
			
			rental_period_lower = (rental_start + trunc(random() * 1439) * '1 minute'::INTERVAL);
			rental_period_upper = (rental_period_lower + trunc(random() * 1440) * '1 minute'::INTERVAL);
		
			-- Sometimes loading history can deplete a "store" of inventory. For now, just skip it and
			-- catch up on future dates. Will need to populate stores with more inventory to compensate
			IF c_inv IS NOT NULL THEN 
			 	INSERT INTO bluebox.rental (rental_period, inventory_id, customer_id, store_id)
			 	SELECT tstzrange(rental_period_lower,rental_period_upper) rental_period,
					c_inv,
					cus.customer_id,
					cus.store_id;
			END IF;
			 
			COMMIT;
		
			a_inv := array_append(a_inv, c_inv);
			
	 	end LOOP;
		
	    COMMIT;
		
		CALL bluebox.insert_payments(rental_start::date);
	
		rental_start = rental_nextday;
		
	
		RAISE NOTICE 'Next day: %', rental_start;
	
	end LOOP; -- WHILE LOOP

 END;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.generate_new_rentals(interval, real, real, integer)...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.generate_new_rentals(IN rental_interval interval DEFAULT '00:05:00'::interval, IN cust_percent real DEFAULT 0.025, IN holiday_multiplier real DEFAULT 2.5, IN max_store_dist integer DEFAULT 25000)
LANGUAGE plpgsql
AS $_$
 DECLARE cus record;
	c_inv int;
	a_inv int[];
	rental_start timestamptz;
    rental_nextday timestamptz;
    rental_range tstzrange;
	sqlstr TEXT;
	pid int;
	tmp_cust_tablename TEXT;
	tmp_inv_tablename TEXT;
 BEGIN

	SELECT pg_backend_pid() INTO pid; 
	
	tmp_cust_tablename = 'tmp_av_customer_' || pid::TEXT;
	tmp_inv_tablename = 'tmp_av_inventory_' || pid::TEXT;
	 
	EXECUTE 'CREATE TEMPORARY TABLE ' || tmp_cust_tablename || ' (LIKE bluebox.customer INCLUDING ALL)';
	EXECUTE 'CREATE TEMPORARY TABLE ' || tmp_inv_tablename || ' (LIKE bluebox.inventory INCLUDING ALL)';
	EXECUTE 'CREATE INDEX tmp_av_inventory_id_' || pid::TEXT || ' ON ' || tmp_inv_tablename || '(inventory_id)';
	EXECUTE 'CREATE INDEX tmp_av_inventory_storeid_' || pid::TEXT || ' ON ' || tmp_inv_tablename || '(store_id)';

	rental_start = now();
	rental_range = tstzrange(now(),now()+rental_interval);

	IF EXISTS (SELECT 1 FROM bluebox.holiday WHERE holiday_date::timestamptz <@ rental_range) THEN 
		SELECT pct INTO cust_percent FROM random_between(cust_percent,cust_percent*holiday_multiplier,3) x(pct);
	END IF;
	
		-- Get a list of inventory that is currently on loan as of the rental_start day
		-- For new rentals this is a bit faulty as the "rental_start" is a single timestamp
		-- but the start time 
		sqlstr := FORMAT($$WITH outstanding_rentals AS (
			SELECT * FROM bluebox.rental
			WHERE rental_period @> %3$L
		),
		-- get a list of inventory that is available
		available_inventory AS (
			INSERT INTO  %1$I --tmp_av_inventory
			SELECT i.* FROM bluebox.inventory i
				LEFT JOIN outstanding_rentals o using(inventory_id)
			WHERE o.inventory_id IS NULL
		)
		-- get a list of customers that do not currently have a video on loan
		-- as of this time
		INSERT INTO %2$I --tmp_av_customer
		SELECT c.* FROM bluebox.customer c
		 	LEFT JOIN outstanding_rentals o using(customer_id)
		WHERE o.customer_id IS NULL
			AND c.activebool IS TRUE;
		$$,tmp_inv_tablename, tmp_cust_tablename, rental_range);
		
		--RAISE NOTICE '%',sqlstr;
	
		EXECUTE sqlstr;
	
		-- sample 0.01% of the rows from available customers for the given day 
		-- loop over them and
	 	FOR cus IN EXECUTE FORMAT('SELECT customer_id, store_id FROM %1$I TABLESAMPLE bernoulli(%2$L)',tmp_cust_tablename,cust_percent)
	 	LOOP
		 	-- This is not efficient on larger tables. For a small table like this
		 	-- using 'random()' to order is faster and easier than a multi-step search
		 	WITH store_inv AS (
				SELECT s.store_id, ST_Distance(s.geog,c.geog) dist FROM bluebox.store s,
					bluebox.customer c
				WHERE ST_DWithin(s.geog,c.geog,max_store_dist)
					AND c.customer_id = cus.customer_id
				ORDER BY random()
				LIMIT 1
			)
			SELECT store_id INTO cus.store_id FROM store_inv;
		 	
		 	EXECUTE FORMAT($$SELECT inventory_id FROM %1$I 
		 		WHERE inventory_id NOT IN (SELECT UNNEST(%2$L::int[]))
		 			AND store_id = %3$s
		 		ORDER BY random()
		 		LIMIT 1$$,tmp_inv_tablename,a_inv,cus.store_id) INTO c_inv;
		 	
		 	--RAISE NOTICE 'customer_id: %, inventory_id: %, a_inv: %',cus.customer_id, c_inv, a_inv;
		 	
		 	sqlstr := FORMAT($$INSERT INTO bluebox.rental (rental_period, inventory_id, customer_id, store_id)
			 	VALUES (tstzrange((%1$L::timestamptz + trunc(random() * 300) * '1 second'::INTERVAL),NULL),
					%2$s,
					%3$s,
					%4$s) 
					$$,rental_start,c_inv,cus.customer_id,cus.store_id); 
					
 			RAISE NOTICE '%',sqlstr;				
			EXECUTE sqlstr;
 			COMMIT;
		
			a_inv := array_append(a_inv, c_inv);
			
	 	end LOOP;
	 	--RAISE NOTICE '%',sqlstr;
	 	--EXECUTE sqlstr;
	 
		EXECUTE 'DROP TABLE ' || tmp_cust_tablename;
		EXECUTE 'DROP TABLE ' || tmp_inv_tablename; 

 END;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.generate_individual_rental(integer)...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.generate_individual_rental(IN max_store_dist integer DEFAULT 25000)
LANGUAGE plpgsql
AS $_$
 DECLARE cus record;
	c_id int;
	c_sid int;
	inv_id int;
	rental_start timestamptz;
    rental_nextday timestamptz;
    rental_range tstzrange;
	sqlstr TEXT;
	pid int;
	tmp_cust_tablename TEXT;
	tmp_inv_tablename TEXT;
 BEGIN

	rental_start = now();
	
	-- Get a random customer to rent a movie for
	SELECT customer_id INTO c_id FROM customer 
		WHERE customer_id NOT IN (SELECT customer_id from rental WHERE rental_period @> rental_start)
		ORDER BY random()
		LIMIT 1;
	
	
	WITH rental_store AS (
		SELECT s.store_id, ST_Distance(s.geog,c.geog) dist FROM bluebox.store s,
			bluebox.customer c
		WHERE ST_DWithin(s.geog,c.geog,max_store_dist)
			AND c.customer_id = c_id
		ORDER BY random()
		LIMIT 1
	)
	SELECT store_id INTO c_sid FROM rental_store;
	 	
 	SELECT inventory_id INTO inv_id FROM inventory
 		WHERE inventory_id NOT IN (SELECT inventory_id FROM rental WHERE rental_period @> rental_start)
 			AND store_id = c_sid
 		ORDER BY random()
 		LIMIT 1;
	 	
	IF (inv_id IS NOT NULL) THEN  	
		INSERT INTO bluebox.rental (rental_period, inventory_id, customer_id, store_id)
			 	VALUES (tstzrange(rental_start,NULL),
					inv_id,
					c_id,
					c_sid); 
	END IF;

	COMMIT;	
 END;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.complete_recent_rentals(interval, integer)...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.complete_recent_rentals(IN min_rental_interval interval DEFAULT '24:00:00'::interval, IN max_store_dist integer DEFAULT 25000)
LANGUAGE plpgsql
AS $_$
 DECLARE 
	pid int;
 	rid int;
	cus_id int;
	inv_id int;
	sid int;
	r_sid int;
	tmp_rental_tablename TEXT;
	sqlstr TEXT;
 BEGIN
	 
	SELECT pg_backend_pid() INTO pid; 
	
	tmp_rental_tablename = 'tmp_open_rentals_' || pid::TEXT;
 
	RAISE NOTICE '%',tmp_rental_tablename;

	EXECUTE FORMAT($$CREATE TEMPORARY TABLE %1$I (
		rental_id int,
		customer_id int,
		inventory_id int,
		store_id int
	);$$,tmp_rental_tablename);


	EXECUTE FORMAT($$INSERT INTO %1$I 
	SELECT rental_id, customer_id, inventory_id, store_id FROM bluebox.rental WHERE upper(rental_period) IS NULL 
		AND lower(rental_period) < now()-%2$L::INTERVAL;$$,tmp_rental_tablename,min_rental_interval);


	EXECUTE 'ANALYZE ' || tmp_rental_tablename;
	-- sample 0.01% of the rows from available customers for the given day 
	-- loop over them and

	FOR rid,cus_id,inv_id,r_sid IN EXECUTE FORMAT('SELECT rental_id, customer_id, inventory_id,store_id FROM %1$I TABLESAMPLE bernoulli(random_between(10,20,1))',tmp_rental_tablename)
 	LOOP
	 	-- update the rental end period to be between 16 hours and 4 days from initial rental.
	 	-- end the rental between 16 hours and 96 hours after start
	 	UPDATE bluebox.rental SET rental_period = tstzrange(lower(rental_period), (lower(rental_period) + (random_between(57600,345600)::TEXT || ' seconds')::INTERVAL))
	 	WHERE rental_id = rid;
	 
	 	-- Find a store that's within the specified distance. This will give some randomness
	 	-- to the rental locations for each customer
	 	WITH store_inv AS (
			SELECT s.store_id, ST_Distance(s.geog,cus.geog) dist FROM bluebox.store s,
				bluebox.customer cus
			WHERE ST_DWithin(s.geog,cus.geog,max_store_dist)
				AND cus.customer_id = cus_id
			ORDER BY random()
			LIMIT 1
		)
		SELECT store_id INTO sid FROM store_inv;
	
		IF sid IS NULL THEN
			sid := r_sid;
		END IF;
	
        UPDATE bluebox.inventory SET store_id = sid
		WHERE inventory_id = inv_id; 
		
		COMMIT;
		
		sid:=NULL;
	
		CALL bluebox.insert_single_payment(rid);
		
 	end LOOP;	 
	 
 	EXECUTE 'DROP TABLE ' || tmp_rental_tablename;


 END;
$_$;

SET check_function_bodies = true;
